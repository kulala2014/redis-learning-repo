# Redis 缓存模式与锁机制总结

本文档总结了关于多级缓存、缓存更新策略、分布式锁以及数据库锁的相关知识点。

## 1. 多级缓存架构 (Multi-Level Caching)

**架构模式**：L1 (本地内存/In-Process Memory) + L2 (Redis/Distributed Cache)

### 适用场景
不仅仅适用于秒杀场景，适用于任何 **“读多写少”** 且对性能要求极高的通用业务场景，例如：
- 内容管理系统 (CMS) 的热点文章
- 电商商品详情页
- 全局配置中心
- 数据字典

### 核心优势
1.  **极致性能**：L1 缓存无网络开销，纳秒级读取。
2.  **保护数据库**：防止缓存击穿（热点 Key 失效）和缓存雪崩（大量 Key 同时失效）。
3.  **防止穿透**：通过缓存空值（Null Object Pattern）防止恶意请求打穿到数据库。

---

## 2. L1 与 L2 数据一致性处理

在集群环境下，修改数据后，各节点的 L1 缓存可能存在不一致。

### 策略 A：短 TTL (被动过期) - **推荐**
- **做法**：给 L1 缓存设置极短的过期时间（如 5-30秒）。
- **适用**：大多数允许短暂数据延迟的互联网业务。
- **优点**：实现简单，无额外架构复杂度。

### 策略 B：Redis Pub/Sub (主动通知)
- **做法**：更新数据时，通过 Redis 发布消息；所有应用节点订阅频道，收到消息后主动清除本地 L1 缓存。
- **适用**：对实时性要求极高（秒级以内）的场景。
- **缺点**：增加了代码复杂度和系统耦合度。

---

## 3. 缓存更新策略 (Cache-Aside Pattern)

在 `Create` 或 `Update` 操作中，推荐的执行顺序是：
1.  **先更新数据库**
2.  **获取分布式锁**
3.  **删除/更新缓存**

### 为什么先更新数据库？
- **提高并发度**：数据库操作（I/O）通常较慢。如果在 DB 操作期间一直持有锁，会阻塞所有读请求。后加锁可以让读请求在 DB 更新期间继续并发执行（虽然可能读到旧值）。

### 为什么还需要锁？
- **防止脏数据覆盖**：解决经典的“读写竞争”问题。
    - *场景*：线程 A (读) 查到旧值 -> 线程 B (写) 更新 DB 并删缓存 -> 线程 A 把旧值回写到缓存。
    - *解决*：锁保证了“缓存重建”和“缓存失效”的串行化，确保最后一次操作一定是清除缓存或写入新值。

### 3.1 深入解析：为什么不加锁数据库也不会乱？

**误区**：认为应用层不加锁，并发更新数据库会导致数据覆盖混乱。

**真相**：
1.  **数据库层面的并发控制**：
    - 数据库（如 SQL Server/MySQL）自带强大的行级锁（Row Lock）。
    - 当多个线程并发更新同一行时，数据库会自动排队（串行化执行）。
    - **结果**：后执行的更新覆盖先执行的更新（Last Write Wins），数据完整性由数据库保证，不会损坏。

2.  **那为什么还要加 Redis 分布式锁？**
    - **目的不是保护数据库，而是保护缓存！**
    - **防止“双写不一致”**：
        - 如果没有锁，读线程可能读取到旧的 DB 数据。
        - 在写线程更新完 DB 并删除缓存后。
        - 读线程因为网络卡顿，延迟将旧数据回写到缓存。
        - **后果**：缓存中长期保存脏数据，与 DB 不一致。
    - **锁的作用**：强制将“缓存重建（读）”和“缓存失效（写）”这两个操作串行化。

---

## 4. 锁的分类与对比

### 4.1 乐观锁 (Optimistic Locking)
- **核心思想**：假设冲突不会发生，只在提交时检查数据是否被修改过。
- **实现方式**：在数据库表中增加 `Version` 或 `Timestamp` 字段。
    ```sql
    UPDATE Products SET Price = 200, Version = Version + 1 
    WHERE Id = 1 AND Version = 5;
    ```
- **适用场景**：
    - 读多写少。
    - 长事务/长业务流程（不占用数据库连接）。
    - 防止“丢失更新” (Lost Update)。

### 4.2 悲观锁 (Pessimistic Locking)
- **核心思想**：假设冲突一定会发生，读取时直接锁死数据。
- **实现方式**：数据库层面的 `SELECT ... FOR UPDATE`。
- **适用场景**：
    - 强一致性要求（如银行转账）。
    - 写冲突激烈的关键业务。
- **缺点**：并发性能差，容易导致死锁。

### 4.3 分布式锁 (RedLock)
- **位置**：应用层/Redis 层。
- **对比**：RedLock 也是一种悲观锁，但作用于分布式系统层面，性能远高于数据库悲观锁。

---

## 5. Redis Lua 脚本

### 什么是 Lua 脚本？
Redis 的“存储过程”，允许将多条命令打包发送给 Redis 执行。

### 核心价值：原子性 (Atomicity)
Redis 保证脚本执行期间，**不会插入其他任何命令**。要么全成功，要么全失败。

### 典型应用
- **检查并执行 (Check-and-Act)**：如秒杀扣库存。
    - *逻辑*：查库存 -> 判断 > 0 -> 扣减。这三步必须原子执行，否则会超卖。
- **复杂的数据结构操作**：如批量写入 Set 并设置过期时间。

### C# 使用示例
```csharp
var result = await db.ScriptEvaluateAsync(script, keys, values);
```
